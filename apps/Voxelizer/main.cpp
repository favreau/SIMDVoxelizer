/* Copyright (c) 2015-2017, EPFL/Blue Brain Project
 * All rights reserved. Do not distribute without permission.
 * Responsible Author: Cyrille Favreau <cyrille.favreau@epfl.ch>
 *                     Grigori Chevtchenko <grigori.chevtchenko@epfl.ch>
 *
 * This file is part of SIMDVoxelizer <https://github.com/favreau/SIMDVoxelizer>
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 3.0 as published
 * by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <limits>
#include <map>
#include <simdvoxelizer/Octree.h>
#include <simdvoxelizer/SIMDSparseVoxelizer_ispc.h>
#include <sstream>
#include <string>
#include <vector>
#include <memory>
#include <stdexcept>

namespace
{

  // Configuration parameters
  struct Config
  {
    float voxelSize{2.0f};
    int span{32};
    std::string inputFile;
    std::string outputFile;
    glm::vec3 minAABB;
    glm::vec3 maxAABB;
    bool hasCustomBoundingBox{false};
  };

  // Volume metadata
  struct VolumeMetadata
  {
    glm::vec3 dimensions;
    glm::vec3 offset;
    glm::vec3 elementSpacing;
    std::string filename;
  };

  // Utility functions
  inline uint32_t pow2roundup(uint32_t x)
  {
    --x;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    return x + 1;
  }

  // File handling class
  class FileHandler
  {
  public:
    static std::vector<float> readEvents(const std::string &filename)
    {
      std::vector<float> events;
      std::ifstream file(filename, std::ios::in | std::ios::binary);
      if (!file.is_open())
      {
        throw std::runtime_error("Failed to open input file: " + filename);
      }

      while (!file.eof())
      {
        float v;
        file.read(reinterpret_cast<char *>(&v), sizeof(float));
        events.push_back(v);
      }
      return events;
    }

    static void writeVolume(const std::string &filename, const std::vector<char> &data)
    {
      std::ofstream volumeFile(filename, std::ios::out | std::ios::binary);
      if (!volumeFile.is_open())
      {
        throw std::runtime_error("Failed to open output file: " + filename);
      }
      volumeFile.write(data.data(), sizeof(char) * data.size());
    }
  };

  // Volume writer class
  class VolumeWriter
  {
  public:
    static void writeMHDHeader(const VolumeMetadata &metadata)
    {
      const std::string mhdFilename = metadata.filename + ".mhd";
      std::ofstream mhdFile(mhdFilename, std::ofstream::out);
      if (!mhdFile.is_open())
      {
        throw std::runtime_error("Failed to write MHD header file");
      }

      mhdFile << "ObjectType = Image\n"
              << "NDims = 3\n"
              << "BinaryData = True\n"
              << "BinaryDataByteOrderMSB = False\n"
              << "CompressedData = False\n"
              << "TransformMatrix = 1 0 0 0 1 0 0 0 1\n"
              << "Offset = " << metadata.offset.x << " " << metadata.offset.y << " " << metadata.offset.z << "\n"
              << "CenterOfRotation = 0 0 0\n"
              << "AnatomicalOrientation = RAI\n"
              << "ElementSpacing = " << metadata.elementSpacing.x << " "
              << metadata.elementSpacing.y << " " << metadata.elementSpacing.z << "\n"
              << "DimSize = " << metadata.dimensions.x << " "
              << metadata.dimensions.y << " " << metadata.dimensions.z << "\n"
              << "ElementType = MET_UCHAR\n"
              << "ElementDataFile = "
              << metadata.filename.substr(metadata.filename.find_last_of("\\/") + 1) << "\n";
    }

    static void writeOSPHeader(const VolumeMetadata &metadata)
    {
      const std::string ospFilename = metadata.filename + ".osp";
      std::ofstream ospFile(ospFilename, std::ofstream::out);
      if (!ospFile.is_open())
      {
        throw std::runtime_error("Failed to write OSP header file");
      }

      const float ratio = 0.001f * int(1000.f / std::min(metadata.elementSpacing.x,
                                                         std::min(metadata.elementSpacing.y, metadata.elementSpacing.z)));

      ospFile << "<?xml version=\"1.0\"?>\n"
              << "<!-- Generated by SIMDVoxelizer -->\n"
              << "<volume name=\"volume\">\n"
              << "  <voxelType>uchar</voxelType>\n"
              << "  <dimensions> " << metadata.dimensions.x << " "
              << metadata.dimensions.y << " " << metadata.dimensions.z << " </dimensions>\n"
              << "  <samplingRate>1.0</samplingRate>\n"
              << "  <gridOrigin> " << metadata.offset.x << " " << metadata.offset.y
              << " " << metadata.offset.z << " </gridOrigin>\n"
              << "  <gridSpacing> " << ratio * metadata.elementSpacing.x << " "
              << ratio * metadata.elementSpacing.y << " "
              << ratio * metadata.elementSpacing.z << " </gridSpacing>\n"
              << "  <filename> "
              << metadata.filename.substr(metadata.filename.find_last_of("\\/") + 1)
              << " </filename>\n"
              << "</volume>\n";
    }
  };

  // Volume processor class
  class VolumeProcessor
  {
  public:
    static std::vector<char> processVolume(const std::vector<float> &volume)
    {
      // Find value range
      float minValue = std::numeric_limits<float>::max();
      float maxValue = -std::numeric_limits<float>::max();

      for (float value : volume)
      {
        if (value != 0.f)
        {
          minValue = std::min(minValue, value);
          maxValue = std::max(maxValue, value);
        }
      }

      // Normalize volume
      const float scale = 255.f / (maxValue - minValue);
      std::cout << "Normalization [" << minValue << " - " << maxValue << "] " << scale << std::endl;

      std::vector<char> normalizedVolume(volume.size());
      for (size_t i = 0; i < volume.size(); ++i)
      {
        normalizedVolume[i] = static_cast<char>((volume[i] - minValue) * scale);
      }

      return normalizedVolume;
    }
  };

  // Main processing function
  void processVoxelization(const Config &config)
  {
    // Read input events
    std::vector<float> events = FileHandler::readEvents(config.inputFile);

    // Calculate event bounding box
    glm::vec3 eventMinAABB(std::numeric_limits<float>::max());
    glm::vec3 eventMaxAABB(-std::numeric_limits<float>::max());

    for (size_t i = 0; i < events.size(); i += 5)
    {
      if (events[i + 4] != 0.f)
      {
        eventMinAABB = {
            std::min(eventMinAABB.x, events[i]),
            std::min(eventMinAABB.y, events[i + 1]),
            std::min(eventMinAABB.z, events[i + 2])};
        eventMaxAABB = {
            std::max(eventMaxAABB.x, events[i]),
            std::max(eventMaxAABB.y, events[i + 1]),
            std::max(eventMaxAABB.z, events[i + 2])};
      }
    }

    // Handle custom bounding box if provided
    if (config.hasCustomBoundingBox)
    {
      // Add anchor events at corners
      const std::vector<glm::vec3> corners = {
          {config.minAABB.x, config.minAABB.y, config.minAABB.z},
          {config.maxAABB.x, config.minAABB.y, config.minAABB.z},
          {config.minAABB.x, config.maxAABB.y, config.minAABB.z},
          {config.maxAABB.x, config.maxAABB.y, config.minAABB.z},
          {config.minAABB.x, config.minAABB.y, config.maxAABB.z},
          {config.maxAABB.x, config.minAABB.y, config.maxAABB.z},
          {config.minAABB.x, config.maxAABB.y, config.maxAABB.z},
          {config.maxAABB.x, config.maxAABB.y, config.maxAABB.z}};

      for (const auto &corner : corners)
      {
        events.insert(events.end(), {corner.x, corner.y, corner.z, 0.f, 0.f});
      }

      eventMinAABB = {
          std::min(eventMinAABB.x, config.minAABB.x),
          std::min(eventMinAABB.y, config.minAABB.y),
          std::min(eventMinAABB.z, config.minAABB.z)};
      eventMaxAABB = {
          std::max(eventMaxAABB.x, config.maxAABB.x),
          std::max(eventMaxAABB.y, config.maxAABB.y),
          std::max(eventMaxAABB.z, config.maxAABB.z)};
    }

    // Build octree and process volume
    Octree morphoOctree(events, config.voxelSize, eventMinAABB, eventMaxAABB);
    const uint64_t volumeBytes = morphoOctree.getVolumeSize();
    const glm::uvec3 volumeDim = morphoOctree.getVolumeDim();
    const glm::vec3 sceneSize = eventMaxAABB - eventMinAABB;
    const glm::vec3 volumeElementSpacing = sceneSize / glm::vec3(volumeDim);

    // Print processing information
    std::cout << "--------------------------------------------\n"
              << "SIMDVoxelizer\n"
              << "--------------------------------------------\n"
              << "Element spacing   : " << config.voxelSize << "\n"
              << "Span             : " << config.span << "\n"
              << "Input file       : " << config.inputFile << "\n"
              << "Output file      : " << config.outputFile << "\n"
              << "Scene AABB       : [" << eventMinAABB.x << "," << eventMinAABB.y << ","
              << eventMinAABB.z << "] [" << eventMaxAABB.x << "," << eventMaxAABB.y << ","
              << eventMaxAABB.z << "]\n"
              << "Scene size       : [" << sceneSize.x << "," << sceneSize.y << ","
              << sceneSize.z << "]\n"
              << "Volume offset    : [" << eventMinAABB.x << "," << eventMinAABB.y << ","
              << eventMinAABB.z << "]\n"
              << "Volume dimensions: [" << volumeDim.x << ", " << volumeDim.y << ", "
              << volumeDim.z << "] " << volumeBytes << " bytes\n"
              << "--------------------------------------------\n";

    // Process volume in chunks
    std::vector<float> volume(volumeBytes, 0);
    const uint32_t zLength = 8;
    for (uint32_t zOffset = 0; zOffset < volumeDim.z; zOffset += zLength)
    {
      const size_t progress = float(zOffset) / float(volumeDim.z) * 100.f;
      std::cout << progress << "%\r" << std::flush;

      ispc::SIMDSparseVoxelizer_ispc(zOffset, zOffset + zLength, config.span,
                                     config.voxelSize, morphoOctree.getOctreeSize(), volumeDim.x,
                                     volumeDim.y, volumeDim.z, morphoOctree.getFlatIndexes(),
                                     morphoOctree.getFlatData(), volume.data());
    }
    std::cout << "\n";

    // Process and write volume
    std::vector<char> normalizedVolume = VolumeProcessor::processVolume(volume);
    FileHandler::writeVolume(config.outputFile, normalizedVolume);

    // Write metadata files
    VolumeMetadata metadata{
        volumeDim,
        eventMinAABB,
        volumeElementSpacing,
        config.outputFile};
    VolumeWriter::writeMHDHeader(metadata);
    VolumeWriter::writeOSPHeader(metadata);
  }

} // namespace

int main(int argc, char *argv[])
{
  try
  {
    if (argc != 5 && argc != 11)
    {
      std::cerr << "usage: SIMDVoxelizer <voxel_size> <span> "
                << "<input_file> <output_file> "
                << "[<minX> <minY> <minZ> <maxX> <maxY> <maxZ>]\n";
      return 1;
    }

    Config config;
    config.voxelSize = std::stof(argv[1]);
    config.span = std::stoi(argv[2]);
    config.inputFile = argv[3];
    config.outputFile = argv[4];

    if (argc == 11)
    {
      config.hasCustomBoundingBox = true;
      config.minAABB = {
          std::stof(argv[5]),
          std::stof(argv[6]),
          std::stof(argv[7])};
      config.maxAABB = {
          std::stof(argv[8]),
          std::stof(argv[9]),
          std::stof(argv[10])};
    }

    processVoxelization(config);
    return 0;
  }
  catch (const std::exception &e)
  {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }
}
